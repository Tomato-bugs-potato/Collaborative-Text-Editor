From 5864457cab7c04e5829da7c9dd4c5c9712271287 Mon Sep 17 00:00:00 2001
From: MichaelGetu-git <michaelgetu21@gmail.com>
Date: Sun, 7 Dec 2025 12:37:07 +0300
Subject: [PATCH 11/12] update: architecure preview update

---
 docs/ARCHITECTURE.md | 1042 ++++++++++++++++++++++++++++--------------
 1 file changed, 687 insertions(+), 355 deletions(-)

diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 7b3f9aa..25c3c23 100644
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -1,441 +1,773 @@
-# Multi-User Distributed Text Editor
-## Complete Technical Documentation
+# Multi-User Distributed Text Editor - Architecture Documentation
+
+## üìã Table of Contents
+1. [System Overview](#system-overview)
+2. [Architecture Diagram](#architecture-diagram)
+3. [Microservices](#microservices)
+4. [Infrastructure Components](#infrastructure-components)
+5. [Data Flow](#data-flow)
+6. [Scalability & High Availability](#scalability--high-availability)
+7. [Technology Stack](#technology-stack)
+8. [Deployment Architecture](#deployment-architecture)
+9. [Security](#security)
 
 ---
 
-## 1. Executive Summary
+## System Overview
 
-A **production-grade real-time collaborative text editor** built on a **microservices architecture** implementing core distributed systems principles. The system enables multiple users to simultaneously edit documents with live synchronization, leveraging **27 containerized services** for horizontal scalability, fault tolerance, and high availability.
+The Multi-User Distributed Text Editor is a **Google Docs clone** built with a **microservices architecture** designed for high scalability, fault tolerance, and real-time collaboration. The system supports multiple users editing documents simultaneously with operational transformation for conflict resolution.
 
----
-
-## 2. Complete Infrastructure Overview
-
-### Container Count by Category
-
-| Category | Count | Components |
-|----------|-------|------------|
-| **Database** | 3 | PostgreSQL Master + 2 Replicas |
-| **Kafka Cluster** | 4 | 3 Brokers + Zookeeper |
-| **Redis Cluster** | 7 | 6 Data Nodes + 1 Init Container |
-| **API Gateways** | 2 | Gateway 1 + Gateway 2 |
-| **Auth Services** | 2 | Auth 1 + Auth 2 |
-| **Document Services** | 2 | Doc 1 + Doc 2 |
-| **Collaboration Services** | 3 | Collab 1 + Collab 2 + Collab 3 |
-| **Reconciliation Services** | 2 | Reconcile 1 + Reconcile 2 |
-| **Load Balancer** | 1 | Nginx |
-| **Client** | 1 | React Frontend |
-| **Monitoring Tools** | 3 | Kafka UI, PgAdmin, Redis Commander |
-| **Total** | **30** | **Full Distributed Stack** |
+### Key Features
+- ‚úÖ Real-time collaborative editing
+- ‚úÖ User authentication with JWT and Google OAuth
+- ‚úÖ Email verification with EmailJS
+- ‚úÖ Document CRUD operations with access control
+- ‚úÖ WebSocket-based real-time synchronization
+- ‚úÖ Distributed architecture with horizontal scaling
+- ‚úÖ High availability with database replication
+- ‚úÖ Event-driven architecture with Kafka
+- ‚úÖ Caching with Redis Cluster
 
 ---
 
-## 3. Architecture Diagram
+## Architecture Diagram
 
 ```mermaid
 graph TB
     subgraph "Client Layer"
-        C[React Client + Quill.js<br/>:3000]
+        Client[React Client<br/>Port 3000]
     end
-    
-    subgraph "Load Balancing Layer"
-        N[Nginx Load Balancer<br/>:80/:443]
+
+    subgraph "Load Balancer"
+        Nginx[Nginx Load Balancer<br/>Port 80/443]
     end
-    
-    subgraph "API Gateway Layer - 2 Instances"
-        AG1[API Gateway 1<br/>:4000]
-        AG2[API Gateway 2<br/>:4001]
+
+    subgraph "API Gateway Layer"
+        GW1[API Gateway 1<br/>Port 4000]
+        GW2[API Gateway 2<br/>Port 4001]
     end
-    
-    subgraph "Auth Service Layer - 2 Instances"
-        AS1[Auth Service 1<br/>:3001]
-        AS2[Auth Service 2<br/>:3011]
+
+    subgraph "Microservices Layer"
+        Auth1[Auth Service 1<br/>Port 3001]
+        Auth2[Auth Service 2<br/>Port 3011]
+        Doc1[Document Service 1<br/>Port 3002]
+        Doc2[Document Service 2<br/>Port 3012]
+        Collab1[Collaboration Service 1<br/>Port 3003]
+        Collab2[Collaboration Service 2<br/>Port 3013]
+        Collab3[Collaboration Service 3<br/>Port 3023]
+        Recon1[Reconciliation Service 1]
+        Recon2[Reconciliation Service 2]
     end
-    
-    subgraph "Document Service Layer - 2 Instances"
-        DS1[Document Service 1<br/>:3002]
-        DS2[Document Service 2<br/>:3012]
+
+    subgraph "Message Queue"
+        Kafka1[Kafka Broker 1<br/>Port 9092]
+        Kafka2[Kafka Broker 2<br/>Port 9093]
+        Kafka3[Kafka Broker 3<br/>Port 9094]
+        Zoo[Zookeeper<br/>Port 2181]
     end
-    
-    subgraph "Collaboration Service Layer - 3 Instances"
-        CS1[Collaboration 1<br/>:3003]
-        CS2[Collaboration 2<br/>:3013]
-        CS3[Collaboration 3<br/>:3023]
+
+    subgraph "Cache Layer"
+        Redis1[Redis Node 1<br/>Port 7001]
+        Redis2[Redis Node 2<br/>Port 7002]
+        Redis3[Redis Node 3<br/>Port 7003]
+        Redis4[Redis Node 4<br/>Port 7004]
+        Redis5[Redis Node 5<br/>Port 7005]
+        Redis6[Redis Node 6<br/>Port 7006]
     end
-    
-    subgraph "Reconciliation Layer - 2 Instances"
-        RS1[Reconcile 1]
-        RS2[Reconcile 2]
+
+    subgraph "Database Layer"
+        PGMaster[PostgreSQL Master<br/>Port 5432]
+        PGReplica1[PostgreSQL Replica 1<br/>Port 5433]
+        PGReplica2[PostgreSQL Replica 2<br/>Port 5434]
     end
+
+    Client --> Nginx
+    Nginx --> GW1
+    Nginx --> GW2
     
-    subgraph "PostgreSQL Cluster - Master + 2 Replicas"
-        PGM[(Master<br/>:5432)]
-        PGR1[(Replica 1<br/>:5433)]
-        PGR2[(Replica 2<br/>:5434)]
-    end
+    GW1 --> Auth1
+    GW1 --> Auth2
+    GW1 --> Doc1
+    GW1 --> Doc2
+    GW1 --> Collab1
+    GW1 --> Collab2
+    GW1 --> Collab3
     
-    subgraph "Redis Cluster - 6 Nodes (3 Masters + 3 Replicas)"
-        R1[Node 1<br/>:7001]
-        R2[Node 2<br/>:7002]
-        R3[Node 3<br/>:7003]
-        R4[Node 4<br/>:7004]
-        R5[Node 5<br/>:7005]
-        R6[Node 6<br/>:7006]
-    end
+    GW2 --> Auth1
+    GW2 --> Auth2
+    GW2 --> Doc1
+    GW2 --> Doc2
+    GW2 --> Collab1
+    GW2 --> Collab2
+    GW2 --> Collab3
+
+    Auth1 --> PGMaster
+    Auth2 --> PGMaster
+    Doc1 --> PGMaster
+    Doc2 --> PGMaster
+    Doc1 --> Redis1
+    Doc2 --> Redis1
     
-    subgraph "Kafka Cluster - 3 Brokers"
-        ZK[Zookeeper<br/>:2181]
-        K1[Broker 1<br/>:9092]
-        K2[Broker 2<br/>:9093]
-        K3[Broker 3<br/>:9094]
-    end
+    Collab1 --> Redis1
+    Collab2 --> Redis1
+    Collab3 --> Redis1
     
-    C --> N
-    N --> AG1 & AG2
-    AG1 & AG2 --> AS1 & AS2
-    AG1 & AG2 --> DS1 & DS2
-    AG1 & AG2 --> CS1 & CS2 & CS3
+    Doc1 --> Kafka1
+    Doc2 --> Kafka1
+    Collab1 --> Kafka1
+    Collab2 --> Kafka1
+    Collab3 --> Kafka1
     
-    AS1 & AS2 --> PGM
-    DS1 & DS2 --> PGM
-    DS1 & DS2 --> R1 & R2 & R3
-    DS1 & DS2 --> K1 & K2 & K3
+    Recon1 --> Kafka1
+    Recon2 --> Kafka1
+    Recon1 --> PGMaster
+    Recon2 --> PGMaster
     
-    CS1 & CS2 & CS3 --> PGM
-    CS1 & CS2 & CS3 --> R1 & R2 & R3
-    CS1 & CS2 & CS3 --> K1 & K2 & K3
+    Kafka1 --> Zoo
+    Kafka2 --> Zoo
+    Kafka3 --> Zoo
     
-    RS1 & RS2 --> K1 & K2 & K3
+    PGMaster -.Replication.-> PGReplica1
+    PGMaster -.Replication.-> PGReplica2
     
-    PGM -.->|Streaming Replication| PGR1 & PGR2
-    K1 & K2 & K3 --> ZK
-    R1 -.-> R4
-    R2 -.-> R5
-    R3 -.-> R6
+    Redis1 -.Cluster.-> Redis2
+    Redis2 -.Cluster.-> Redis3
+    Redis3 -.Cluster.-> Redis4
+    Redis4 -.Cluster.-> Redis5
+    Redis5 -.Cluster.-> Redis6
+    Redis6 -.Cluster.-> Redis1
 ```
 
 ---
 
-## 4. Distributed System Capabilities - Deep Dive
+## Microservices
 
-### 4.1 Horizontal Scaling (Stateless Microservices)
+### 1. **API Gateway** (2 instances)
+**Ports**: 4000, 4001
 
-| Service | Instances | Scaling Strategy |
-|---------|-----------|------------------|
-| API Gateway | 2 | Stateless, round-robin via Nginx |
-| Auth Service | 2 | Stateless, JWT-based (no session state) |
-| Document Service | 2 | Stateless + Redis cache |
-| Collaboration Service | 3 | Redis Adapter for cross-instance pub/sub |
-| Reconciliation Service | 2 | Kafka consumer group (partitioned) |
+**Responsibilities**:
+- Single entry point for all client requests
+- Request routing to appropriate microservices
+- Load balancing across service instances
+- Authentication middleware
+- Rate limiting (100 req/min general, 10 req/15min for auth)
+- Request/response transformation
+- CORS handling
 
-**How it works:**
-- Each service instance is identical and interchangeable
-- Nginx distributes incoming traffic across all gateway instances
-- API Gateway further distributes to service instances using round-robin
-- No sticky sessions required (except WebSocket - handled by Redis Adapter)
+**Technology**: Express.js, http-proxy-middleware
+
+**Key Features**:
+- Health check endpoint: `/health`
+- Proxy configuration for each service
+- JWT token validation
+- Trust proxy for rate limiting behind Nginx
 
 ---
 
-### 4.2 Database Replication (PostgreSQL)
+### 2. **Auth Service** (2 instances)
+**Ports**: 3001, 3011
+
+**Responsibilities**:
+- User registration with email verification
+- User login with JWT token generation
+- Google OAuth 2.0 integration
+- Password validation (8+ chars, uppercase, lowercase, number, special char)
+- Refresh token management
+- User profile management
+- User search functionality
+
+**Endpoints**:
+- `POST /register` - Register new user
+- `POST /login` - User login
+- `POST /verify-email` - Verify email address
+- `POST /refresh-token` - Refresh access token
+- `GET /profile` - Get user profile
+- `GET /users/search` - Search users
+- `GET /auth/google` - Google OAuth login
+- `GET /auth/google/callback` - Google OAuth callback
+- `POST /logout` - Invalidate refresh token
+
+**Database Schema**:
+```prisma
+model User {
+  id            Int      @id @default(autoincrement())
+  email         String   @unique
+  password      String?
+  name          String
+  googleId      String?  @unique
+  emailVerified Boolean  @default(false)
+  refreshToken  String?
+  createdAt     DateTime @default(now())
+  updatedAt     DateTime @updatedAt
+}
+```
 
-```mermaid
-graph LR
-    subgraph "Write Path"
-        A[Application] -->|INSERT/UPDATE/DELETE| M[(Master :5432)]
-    end
-    
-    subgraph "Streaming Replication"
-        M -->|WAL Stream| R1[(Replica 1 :5433)]
-        M -->|WAL Stream| R2[(Replica 2 :5434)]
-    end
-    
-    subgraph "Read Path (Future)"
-        A -.->|SELECT| R1
-        A -.->|SELECT| R2
-    end
+**Security**:
+- bcrypt password hashing (10 salt rounds)
+- JWT tokens (15min expiry)
+- UUID-based refresh tokens
+- Rate limiting on auth endpoints
+- Joi validation for input
+
+---
+
+### 3. **Document Service** (2 instances)
+**Ports**: 3002, 3012
+
+**Responsibilities**:
+- Document CRUD operations
+- Document metadata management
+- Access control and permissions
+- Document sharing
+- Redis caching for performance
+- Kafka event publishing for document changes
+- Input validation
+
+**Endpoints**:
+- `POST /documents` - Create document
+- `GET /documents` - List user's documents
+- `GET /documents/:id` - Get document by ID
+- `PUT /documents/:id` - Update document
+- `DELETE /documents/:id` - Delete document
+- `POST /documents/:id/share` - Share document with users
+
+**Database Schema**:
+```prisma
+model Document {
+  id        Int      @id @default(autoincrement())
+  title     String
+  content   Json
+  ownerId   Int
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+  shares    DocumentShare[]
+}
+
+model DocumentShare {
+  id         Int      @id @default(autoincrement())
+  documentId Int
+  userId     Int
+  permission String   // 'read' or 'write'
+  document   Document @relation(fields: [documentId], references: [id])
+}
 ```
 
-**Configuration:**
-- **Master (postgres-master:5432):** Handles all write operations
-- **Replica 1 (postgres-replica-1:5433):** Streaming replication, read-only
-- **Replica 2 (postgres-replica-2:5434):** Streaming replication, read-only
-- **Replication Mode:** Asynchronous streaming (low latency, eventual consistency)
+**Caching Strategy**:
+- Cache document content in Redis
+- Cache invalidation on updates
+- TTL-based expiration
 
-**Benefits:**
-- **High Availability:** If master fails, a replica can be promoted
-- **Read Scaling:** Read queries can be distributed to replicas (configurable via env vars `DB_REPLICA_1`, `DB_REPLICA_2`)
-- **Disaster Recovery:** Replicas provide point-in-time recovery capability
+**Kafka Integration**:
+- Publishes `document.created`, `document.updated`, `document.deleted` events
+- Enables event-driven architecture
 
 ---
 
-### 4.3 Distributed Caching (Redis Cluster)
+### 4. **Collaboration Service** (3 instances)
+**Ports**: 3003, 3013, 3023
+
+**Responsibilities**:
+- WebSocket connections for real-time updates
+- Operational Transformation (OT) algorithm via Quill.js
+- Conflict resolution
+- Broadcasting changes to connected clients
+- Redis pub/sub for cross-server communication
+- User presence tracking
+- Cursor position synchronization
+
+**Technology**: Socket.IO, Redis Pub/Sub
+
+**Real-time Events**:
+- `get-document` - Client requests document
+- `send-changes` - Client sends document changes
+- `receive-changes` - Server broadcasts changes
+- `save-document` - Periodic document save
+- `user-joined` - User joins document
+- `user-left` - User leaves document
+- `cursor-position` - Cursor position updates
+
+**Scalability**:
+- Redis pub/sub enables horizontal scaling
+- Multiple Socket.IO servers share state via Redis
+- Sticky sessions via Nginx for WebSocket connections
 
-```mermaid
-graph TB
-    subgraph "Redis Cluster - 6 Nodes"
-        subgraph "Master Nodes (Data Sharding)"
-            M1[Master 1<br/>:7001<br/>Slots 0-5460]
-            M2[Master 2<br/>:7002<br/>Slots 5461-10922]
-            M3[Master 3<br/>:7003<br/>Slots 10923-16383]
-        end
-        subgraph "Replica Nodes (Failover)"
-            S1[Replica 4<br/>:7004]
-            S2[Replica 5<br/>:7005]
-            S3[Replica 6<br/>:7006]
-        end
-        M1 -.->|Replicates to| S1
-        M2 -.->|Replicates to| S2
-        M3 -.->|Replicates to| S3
-    end
-```
+---
+
+### 5. **Reconciliation Service** (2 instances)
+**Background Service** (no HTTP port)
+
+**Responsibilities**:
+- Consume Kafka events
+- Reconcile document state
+- Handle eventual consistency
+- Background data processing
+- Audit logging
 
-**Configuration:**
-- **6 Nodes Total:** 3 Masters + 3 Replicas
-- **Hash Slots:** 16,384 slots divided among 3 masters
-- **Replication Factor:** 1 (each master has 1 replica)
-- **Cluster Mode:** Enabled with automatic failover
+**Kafka Consumer Groups**:
+- `reconciliation-group` - Ensures load balancing
 
-**Use Cases:**
-1. **Document Caching:** Hot documents cached to reduce database load
-2. **Socket.IO Adapter:** Cross-instance WebSocket message broadcasting
-3. **Session State:** Collaboration session data shared across instances
+**Use Cases**:
+- Sync document changes to analytics
+- Generate document history
+- Conflict resolution for offline edits
+- Data integrity checks
 
 ---
 
-### 4.4 Message Queue (Apache Kafka)
+## Infrastructure Components
 
-```mermaid
-graph TB
-    subgraph "Kafka Cluster"
-        ZK[Zookeeper<br/>Cluster Coordination]
-        
-        subgraph "Brokers"
-            B1[Broker 1<br/>ID: 1<br/>:9092]
-            B2[Broker 2<br/>ID: 2<br/>:9093]
-            B3[Broker 3<br/>ID: 3<br/>:9094]
-        end
-        
-        ZK --> B1 & B2 & B3
-    end
-    
-    subgraph "Topics"
-        T1[document-changes<br/>Replication: 3]
-        T2[document-events<br/>Replication: 3]
-    end
-    
-    subgraph "Producers"
-        DS[Document Service]
-        CS[Collaboration Service]
-    end
-    
-    subgraph "Consumers"
-        RS[Reconciliation Service<br/>Consumer Group]
-    end
-    
-    DS -->|Lifecycle Events| T2
-    CS -->|OT Operations| T1
-    T1 & T2 --> RS
-```
+### 1. **PostgreSQL Cluster**
+**Architecture**: Master-Replica (1 master + 2 replicas)
+
+**Master** (Port 5432):
+- Handles all writes
+- Streaming replication to replicas
+- WAL archiving enabled
 
-**Configuration:**
-- **3 Brokers:** kafka-1, kafka-2, kafka-3
-- **Replication Factor:** 3 (topics replicated across all brokers)
-- **Min In-Sync Replicas:** 1 (at least 1 replica must acknowledge)
-- **Consumer Groups:** Reconciliation services share a consumer group for partition distribution
+**Replicas** (Ports 5433, 5434):
+- Read-only queries
+- Automatic failover capability
+- Asynchronous replication
 
-**Topics:**
-| Topic | Producer | Purpose |
-|-------|----------|---------|
-| `document-changes` | Collaboration Service | Real-time OT operations |
-| `document-events` | Document Service | Lifecycle events (create, update, delete) |
+**Configuration**:
+- `max_connections = 100`
+- `shared_buffers = 256MB`
+- `wal_level = replica`
+- `max_wal_senders = 3`
+
+**Databases**:
+- `texteditor` - Auth service
+- `texteditor_docs` - Document service
+- `texteditor_collab` - Collaboration service
 
 ---
 
-### 4.5 Load Balancing (Multi-Layer)
+### 2. **Redis Cluster**
+**Architecture**: 6-node cluster (3 masters + 3 replicas)
+
+**Nodes**:
+- `redis-node-1` (Port 7001) - Master
+- `redis-node-2` (Port 7002) - Master
+- `redis-node-3` (Port 7003) - Master
+- `redis-node-4` (Port 7004) - Replica
+- `redis-node-5` (Port 7005) - Replica
+- `redis-node-6` (Port 7006) - Replica
+
+**Configuration**:
+- Cluster mode enabled
+- Automatic failover
+- Hash slot distribution
+- Hostname-based cluster announcement
+
+**Use Cases**:
+- Document caching (Document Service)
+- Pub/sub for real-time collaboration (Collaboration Service)
+- Session storage
+- Rate limiting counters
 
-```mermaid
-graph LR
-    subgraph "Layer 1: Nginx (L7)"
-        N[Nginx<br/>:80/:443]
-    end
-    
-    subgraph "Layer 2: API Gateway (Application)"
-        AG1[Gateway 1]
-        AG2[Gateway 2]
-    end
-    
-    subgraph "Layer 3: Service Discovery (Docker DNS)"
-        S1[auth-service-1]
-        S2[auth-service-2]
-        S3[document-service-1]
-        S4[document-service-2]
-    end
-    
-    N -->|Round Robin| AG1
-    N -->|Round Robin| AG2
-    AG1 -->|Round Robin| S1 & S2 & S3 & S4
-    AG2 -->|Round Robin| S1 & S2 & S3 & S4
-```
+---
+
+### 3. **Kafka Cluster**
+**Architecture**: 3-broker cluster with Zookeeper
+
+**Brokers**:
+- `kafka-1` (Port 9092)
+- `kafka-2` (Port 9093)
+- `kafka-3` (Port 9094)
 
-**Nginx Configuration:**
-- Distributes traffic to API Gateway instances
-- Health-check based routing (unhealthy instances excluded)
-- WebSocket upgrade support for collaboration
+**Configuration**:
+- Replication factor: 3
+- Min in-sync replicas: 2
+- Transaction state log replication: 3
 
-**API Gateway Load Balancing:**
-- Maintains list of service URLs from environment variables
-- Round-robin selection across service instances
-- Single point of entry for all client requests
+**Topics**:
+- `document-events` - Document CRUD events
+- `collaboration-events` - Real-time editing events
+- `user-events` - User activity events
+
+**Zookeeper** (Port 2181):
+- Cluster coordination
+- Leader election
+- Configuration management
 
 ---
 
-### 4.6 Real-Time Collaboration (Socket.IO + Redis)
+### 4. **Nginx Load Balancer**
+**Port**: 80 (HTTP), 443 (HTTPS)
+
+**Configuration**:
+- Least connections algorithm
+- Health checks every 10s
+- Max fails: 3, Fail timeout: 30s
+- WebSocket upgrade support
+- Proxy buffering enabled
+
+**Upstream**:
+```nginx
+upstream api_gateway {
+    least_conn;
+    server api-gateway-1:4000 max_fails=3 fail_timeout=30s;
+    server api-gateway-2:4000 max_fails=3 fail_timeout=30s;
+}
+```
+
+---
+
+## Data Flow
+
+### 1. **User Registration Flow**
 
-```mermaid
-sequenceDiagram
-    participant U1 as User 1 (Browser)
-    participant CS1 as Collab Service 1
-    participant R as Redis Adapter
-    participant CS2 as Collab Service 2
-    participant U2 as User 2 (Browser)
-    
-    U1->>CS1: connect()
-    U1->>CS1: join-document(docId)
-    CS1->>R: Subscribe to doc room
-    
-    U2->>CS2: connect()
-    U2->>CS2: join-document(docId)
-    CS2->>R: Subscribe to doc room
-    
-    U1->>CS1: send-changes(delta)
-    CS1->>R: Publish to doc room
-    R->>CS2: Forward message
-    CS2->>U2: receive-changes(delta)
-    
-    Note over U1,U2: Changes appear in real-time<br/>across different service instances
+```
+1. Client ‚Üí Nginx ‚Üí API Gateway ‚Üí Auth Service
+   POST /api/auth/register {email, password, name}
+
+2. Auth Service:
+   - Validates password (8+ chars, uppercase, lowercase, number, special char)
+   - Hashes password with bcrypt
+   - Creates user in PostgreSQL (emailVerified=false)
+   - Returns user data
+
+3. Client ‚Üí EmailJS:
+   - Generates 6-character verification code
+   - Sends email with code
+   - Stores code in sessionStorage
+
+4. Client ‚Üí Nginx ‚Üí API Gateway ‚Üí Auth Service
+   POST /api/auth/verify-email {email, verificationCode}
+
+5. Auth Service:
+   - Updates user.emailVerified = true
+   - Returns success
+
+6. Client ‚Üí Nginx ‚Üí API Gateway ‚Üí Auth Service
+   POST /api/auth/login {email, password}
+
+7. Auth Service:
+   - Validates credentials
+   - Checks emailVerified = true
+   - Generates JWT access token (15min)
+   - Generates UUID refresh token
+   - Returns tokens
 ```
 
-**Cross-Instance Communication:**
-- Socket.IO uses Redis Adapter for pub/sub
-- User 1 connected to Collab Service 1
-- User 2 connected to Collab Service 2
-- Both users see each other's changes instantly
+### 2. **Document Editing Flow**
 
----
+```
+1. Client ‚Üí Nginx ‚Üí API Gateway ‚Üí Document Service
+   GET /api/documents/:id
+
+2. Document Service:
+   - Checks Redis cache
+   - If miss: Query PostgreSQL
+   - Cache in Redis
+   - Return document
+
+3. Client establishes WebSocket:
+   Client ‚Üí Nginx ‚Üí Collaboration Service
+   Socket.IO connection
+
+4. Client emits 'get-document':
+   - Collaboration Service loads document from DB
+   - Sends document to client
+
+5. User makes edit:
+   Client emits 'send-changes' {delta}
+
+6. Collaboration Service:
+   - Applies Operational Transformation
+   - Publishes to Redis pub/sub
+   - All Collaboration Service instances receive
+   - Broadcast to all connected clients
+
+7. Periodic save (every 2 seconds):
+   - Collaboration Service ‚Üí Document Service
+   - Document Service updates PostgreSQL
+   - Publishes 'document.updated' to Kafka
+   - Invalidates Redis cache
+
+8. Reconciliation Service:
+   - Consumes Kafka event
+   - Performs background reconciliation
+```
 
-### 4.7 Event-Driven Architecture
+### 3. **Google OAuth Flow**
 
-```mermaid
-graph LR
-    subgraph "Producers"
-        DS[Document Service]
-        CS[Collaboration Service]
-    end
-    
-    subgraph "Kafka"
-        K((Kafka Cluster))
-    end
-    
-    subgraph "Consumers"
-        RS1[Reconciliation 1]
-        RS2[Reconciliation 2]
-    end
-    
-    DS -->|DOCUMENT_CREATED<br/>DOCUMENT_UPDATED<br/>DOCUMENT_DELETED| K
-    CS -->|OT Operations| K
-    K -->|Partition 0| RS1
-    K -->|Partition 1| RS2
 ```
+1. Client clicks "Login with Google"
+   ‚Üí Redirects to /api/auth/auth/google
+
+2. Auth Service ‚Üí Google OAuth:
+   - Redirects to Google login page
+
+3. User authenticates with Google
+   ‚Üí Google redirects to callback URL
+
+4. Auth Service receives callback:
+   - Extracts Google profile
+   - Finds or creates user
+   - Sets emailVerified = true
+   - Generates JWT tokens
+
+5. Auth Service ‚Üí Client:
+   - Redirects to /auth/callback?token=...&refreshToken=...
+
+6. Client:
+   - Stores tokens in localStorage
+   - Fetches user profile
+   - Redirects to dashboard
+```
+
+---
+
+## Scalability & High Availability
+
+### Horizontal Scaling
+- **API Gateway**: 2 instances behind Nginx
+- **Auth Service**: 2 instances
+- **Document Service**: 2 instances
+- **Collaboration Service**: 3 instances (WebSocket heavy)
+- **Reconciliation Service**: 2 instances (Kafka consumer group)
+
+### Database Replication
+- **PostgreSQL**: 1 master + 2 replicas
+  - Writes ‚Üí Master
+  - Reads ‚Üí Load balanced across replicas
+  - Automatic failover with pg_auto_failover (future)
+
+### Caching Strategy
+- **Redis Cluster**: 3 masters + 3 replicas
+  - Document content caching
+  - Session storage
+  - Pub/sub for real-time events
+
+### Message Queue
+- **Kafka**: 3 brokers
+  - Event-driven architecture
+  - Decouples services
+  - Enables eventual consistency
+
+### Load Balancing
+- **Nginx**: Least connections algorithm
+  - Health checks
+  - Automatic failover
+  - WebSocket sticky sessions
+
+---
+
+## Technology Stack
+
+| Component | Technology | Version | Purpose |
+|-----------|-----------|---------|---------|
+| **Frontend** | React.js | 18.1.0 | UI framework |
+| | Quill.js | 1.3.7 | Rich text editor with OT |
+| | Socket.IO Client | 4.5.0 | WebSocket client |
+| | EmailJS | 4.1.0 | Email verification |
+| **Backend** | Node.js | 18 | Runtime |
+| | Express.js | Latest | Web framework |
+| | Socket.IO | 4.5.0 | WebSocket server |
+| | Prisma | Latest | ORM |
+| | Passport.js | Latest | OAuth |
+| **Database** | PostgreSQL | 15 | Primary database |
+| | Redis | 7 | Cache & pub/sub |
+| **Message Queue** | Apache Kafka | 7.5.0 | Event streaming |
+| | Zookeeper | 7.5.0 | Kafka coordination |
+| **Load Balancer** | Nginx | Alpine | Reverse proxy |
+| **Containerization** | Docker | Latest | Containers |
+| | Docker Compose | Latest | Orchestration |
+| **Security** | bcrypt.js | Latest | Password hashing |
+| | jsonwebtoken | Latest | JWT tokens |
+| | Joi | Latest | Input validation |
+| **Monitoring** | Kafka UI | Latest | Kafka dashboard |
+| | pgAdmin | Latest | PostgreSQL GUI |
+| | Redis Commander | Latest | Redis GUI |
 
-**Event Types:**
-- `DOCUMENT_CREATED`: New document created
-- `DOCUMENT_UPDATED`: Document content/title changed
-- `DOCUMENT_DELETED`: Document removed
-- `COLLABORATOR_ADDED/REMOVED`: Sharing changes
+---
+
+## Deployment Architecture
+
+### Docker Compose Services
+
+**Total Services**: 28 containers
+
+1. **Infrastructure** (13):
+   - postgres-master, postgres-replica-1, postgres-replica-2
+   - redis-node-1 through redis-node-6
+   - redis-cluster-init
+   - zookeeper
+   - kafka-1, kafka-2, kafka-3
+
+2. **Application** (12):
+   - api-gateway-1, api-gateway-2
+   - auth-service-1, auth-service-2
+   - document-service-1, document-service-2
+   - collaboration-service-1, collaboration-service-2, collaboration-service-3
+   - reconciliation-service-1, reconciliation-service-2
+   - nginx
+
+3. **Client** (1):
+   - texteditor-client
+
+4. **Management Tools** (3, optional):
+   - pgadmin
+   - redis-commander
+   - kafka-ui
+
+### Network
+- **Bridge Network**: `distributed-network`
+- All services communicate via Docker DNS
+
+### Volumes
+- `postgres-master-data`
+- `postgres-replica1-data`, `postgres-replica2-data`
+- `redis-node-1-data` through `redis-node-6-data`
+
+### Health Checks
+- PostgreSQL: `pg_isready`
+- API Gateway: HTTP GET `/health`
+- Auth Service: HTTP GET `/health`
+- Document Service: HTTP GET `/health`
+- Nginx: `pgrep nginx`
+- Kafka: `kafka-broker-api-versions`
 
 ---
 
-## 5. Fault Tolerance & High Availability
+## Security
+
+### Authentication
+- **JWT Tokens**: 15-minute expiry
+- **Refresh Tokens**: UUID-based, stored in database
+- **Google OAuth**: Secure third-party authentication
+
+### Password Security
+- **Hashing**: bcrypt with 10 salt rounds
+- **Validation**: 8+ chars, uppercase, lowercase, number, special char
+- **Pattern**: `/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&#^()_+\-=\[\]{}|;:'",.<>\/~`])[A-Za-z\d@$!%*?&#^()_+\-=\[\]{}|;:'",.<>\/~`]{8,}$/`
+
+### Rate Limiting
+- **General**: 100 requests/minute per IP
+- **Auth Endpoints**: 10 requests/15 minutes per IP
+- **Implementation**: express-rate-limit
+
+### CORS
+- Configured on all services
+- Allows cross-origin requests from client
+
+### Network Security
+- Services communicate over internal Docker network
+- Only Nginx, Client, and management tools expose public ports
 
-| Component | Failure Scenario | Handling Mechanism |
-|-----------|------------------|-------------------|
-| **Auth Service** | 1 of 2 instances fails | Nginx routes to healthy instance |
-| **Document Service** | 1 of 2 instances fails | Gateway routes to healthy instance |
-| **Collaboration Service** | 1 of 3 fails | User reconnects to another instance via Redis Adapter |
-| **Reconciliation Service** | 1 of 2 fails | Kafka rebalances partitions to remaining consumer |
-| **PostgreSQL Master** | Master fails | Manual failover to replica (or use Patroni) |
-| **PostgreSQL Replica** | Replica fails | No impact (read queries can use other replica) |
-| **Redis Node** | Master node fails | Cluster promotes replica automatically |
-| **Kafka Broker** | 1 of 3 brokers fails | Other brokers continue (replication factor 3) |
-| **Nginx** | Nginx fails | Single point of failure (add keepalived for HA) |
+### Input Validation
+- **Joi schemas** for all API endpoints
+- SQL injection prevention via Prisma ORM
+- XSS prevention via input sanitization
 
 ---
 
-## 6. What's Implemented vs. What's Missing
-
-### ‚úÖ Implemented Capabilities
-
-| Capability | Implementation Details |
-|------------|------------------------|
-| **Microservices Architecture** | 5 independent services with clear boundaries |
-| **Horizontal Scaling** | Multiple instances of each service |
-| **Database Replication** | PostgreSQL master + 2 streaming replicas |
-| **Distributed Caching** | Redis Cluster (6 nodes, 3 masters + 3 replicas) |
-| **Message Queue** | Kafka Cluster (3 brokers + Zookeeper) |
-| **Real-time Sync** | Socket.IO with Redis Adapter |
-| **Load Balancing** | Nginx (L7) + API Gateway (application) |
-| **Service Discovery** | Docker DNS-based discovery |
-| **Health Checks** | All services have Docker healthchecks |
-| **API Documentation** | Swagger UI for Auth and Document services |
-| **Containerization** | Full Docker Compose orchestration |
-| **Monitoring Tools** | Kafka UI, PgAdmin, Redis Commander |
-
-### ‚ö†Ô∏è Limitations & Missing Features
-
-| Missing Feature | Impact | Recommended Solution |
-|-----------------|--------|---------------------|
-| **True CRDT/OT** | Last-write-wins for concurrent edits | Implement Yjs or Automerge |
-| **Read-Replica Routing** | Replicas not used for reads | Implement read/write splitting |
-| **Circuit Breakers** | Cascading failures possible | Add Resilience4j or Polly |
-| **Distributed Tracing** | Hard to debug cross-service issues | Add Jaeger or Zipkin |
-| **Centralized Logging** | Logs scattered across containers | Add ELK Stack or Loki |
-| **Auto-Scaling** | Manual scaling only | Migrate to Kubernetes with HPA |
-| **Service Mesh** | Limited observability | Add Istio or Linkerd |
-| **OAuth/SSO** | Basic email/password auth only | Add Keycloak or Auth0 |
-| **Rate Limiting** | No request throttling | Add rate limiting middleware |
-| **Database Failover** | Manual replica promotion | Add Patroni or PgPool-II |
+## API Documentation
+
+### Swagger/OpenAPI
+Each service exposes Swagger documentation:
+- **Auth Service**: http://localhost:3001/api-docs
+- **Document Service**: http://localhost:3002/api-docs
+- **Collaboration Service**: http://localhost:3003/api-docs
+
+### Example: Auth Service Swagger
+
+```yaml
+/register:
+  post:
+    summary: Register a new user
+    tags: [Auth]
+    requestBody:
+      required: true
+      content:
+        application/json:
+          schema:
+            type: object
+            required: [email, password, name]
+            properties:
+              email:
+                type: string
+                format: email
+              password:
+                type: string
+                description: Must have 8+ characters with one uppercase letter, one lowercase letter, one number, and one special character
+              name:
+                type: string
+    responses:
+      201:
+        description: User registered successfully
+      400:
+        description: Validation error
+      409:
+        description: User already exists
+```
 
 ---
 
-## 7. Technology Stack Summary
-
-| Layer | Technology | Purpose |
-|-------|------------|---------|
-| **Frontend** | React, Quill.js | Rich text editing |
-| **Real-time** | Socket.IO | WebSocket communication |
-| **API Gateway** | Express.js + http-proxy-middleware | Request routing, load balancing |
-| **Services** | Node.js, Express.js | REST APIs |
-| **ORM** | Prisma | Database access |
-| **Database** | PostgreSQL 15 | Primary data store |
-| **Caching** | Redis 7 (Cluster) | Document caching, pub/sub |
-| **Messaging** | Apache Kafka 7.5 | Event streaming |
-| **Coordination** | Zookeeper | Kafka cluster management |
-| **Load Balancer** | Nginx | Traffic distribution |
-| **Container Runtime** | Docker | Service isolation |
-| **Orchestration** | Docker Compose | Multi-container deployment |
-| **API Docs** | Swagger/OpenAPI | Interactive API documentation |
+## Performance Optimizations
+
+1. **Caching**:
+   - Redis caching for frequently accessed documents
+   - Cache invalidation on updates
+
+2. **Database**:
+   - Read replicas for load distribution
+   - Connection pooling
+   - Indexed queries
+
+3. **Load Balancing**:
+   - Nginx least connections algorithm
+   - Multiple instances of each service
+
+4. **WebSocket**:
+   - Redis pub/sub for cross-server communication
+   - Sticky sessions for connection persistence
+
+5. **Event-Driven**:
+   - Kafka for asynchronous processing
+   - Decouples services for better performance
+
+---
+
+## Monitoring & Observability
+
+### Health Endpoints
+- All services expose `/health` endpoint
+- Nginx health checks every 10s
+
+### Logs
+```bash
+# View all logs
+docker-compose -f docker-compose.distributed.yml logs -f
+
+# View specific service
+docker-compose -f docker-compose.distributed.yml logs auth-service-1
+```
+
+### Management UIs
+- **Kafka UI**: http://localhost:8080
+- **pgAdmin**: http://localhost:5050
+- **Redis Commander**: http://localhost:8081
+
+### Future Enhancements
+- Prometheus metrics
+- Grafana dashboards
+- Distributed tracing (Jaeger)
+- Centralized logging (ELK stack)
 
 ---
 
-## 8. Conclusion
+## Conclusion
 
-This project demonstrates a **comprehensive distributed system** with:
+This Multi-User Distributed Text Editor demonstrates a production-ready microservices architecture with:
 
-- **27-30 containerized services** working in concert
-- **True horizontal scaling** with multiple instances per service
-- **Data redundancy** through PostgreSQL replication and Redis clustering
-- **Async messaging** with a 3-broker Kafka cluster
-- **Real-time collaboration** via Socket.IO with Redis Adapter
-- **Multi-layer load balancing** (Nginx ‚Üí API Gateway ‚Üí Services)
+‚úÖ **Scalability**: Horizontal scaling of all services  
+‚úÖ **High Availability**: Database replication, Redis clustering  
+‚úÖ **Fault Tolerance**: Service isolation, automatic failover  
+‚úÖ **Real-time Collaboration**: WebSocket with Operational Transformation  
+‚úÖ **Event-Driven**: Kafka for asynchronous processing  
+‚úÖ **Security**: JWT auth, password validation, rate limiting  
+‚úÖ **Performance**: Caching, load balancing, connection pooling  
 
-The architecture is **production-ready** for moderate scale and provides a solid foundation for enterprise deployment with the recommended enhancements.
+The architecture is designed to handle thousands of concurrent users while maintaining high performance and reliability.
-- 
2.44.0.windows.1

